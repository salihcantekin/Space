// <auto-generated>
//     Generated by the Space source generator (assembly-scoped registration).
// </auto-generated>

using System;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Space.Abstraction;
using Space.Abstraction.Context;
using Space.Abstraction.Registry;
using Space.Abstraction.Modules;
using Space.Abstraction.Registry.Dispatchers;
using Space.Abstraction.Helpers;

namespace Space.DependencyInjection
{
    // Assembly-scoped registration produced for {{ AssemblyName }}
    internal static class SpaceAssemblyRegistration_{{ AssemblyName | string.replace "-" "_" | string.replace "." "_" }}
    {
        // Registers only handler types (no Space / ModuleFactory / dispatcher singletons)
        public static void RegisterAssemblyServices(IServiceCollection services, ServiceLifetime lifetime)
        {
            var handlerTypes = new Type[] {
                {{ for handler in AllHandlersName }}
                typeof({{ handler }}),
                {{ end }}
            };
            foreach (var t in handlerTypes)
                services.Add(new ServiceDescriptor(t, t, lifetime));
        }

        // Adds handler entries to existing registry (created by root aggregator)
        public static void RegisterAssemblyHandlers(IServiceProvider sp, SpaceRegistry registry, bool isSingleton)
        {
            {{ if NeedsVT }}
            static ValueTask<T> VT<T>(Task<T> task) => task.IsCompletedSuccessfully ? new ValueTask<T>(task.Result) : new ValueTask<T>(task);
            {{ end }}

            {{ if NeedsReg }}
            void Reg<THandler, TReq, TRes>(string name, Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body,
                System.Collections.Generic.IEnumerable<(PipelineConfig config, PipelineInvoker<TReq, TRes> invoker)> pipes = null)
            {
                THandler singleton = isSingleton ? sp.GetRequiredService<THandler>() : default!;
                registry.RegisterHandler<TReq, TRes>(ctx =>
                {
                    var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                    return body(inst, ctx);
                }, name, pipes, null);
            }
            {{ end }}

            {{ if NeedsRegLight }}
            void RegLight<THandler, TReq, TRes>(string name, Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body)
            {
                THandler singleton = isSingleton ? sp.GetRequiredService<THandler>() : default!;
                HandlerInvoker<TReq, TRes> normal = ctx =>
                {
                    var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                    return body(inst, ctx);
                };
                LightHandlerInvoker<TReq, TRes> light = (in LightHandlerContext<TReq> lctx) => LightInvokerHelper.Invoke<TReq, THandler, TRes>(in lctx, singleton, isSingleton, body);
                registry.RegisterHandler<TReq, TRes>(normal, name, null, light);
            }
            {{ end }}

            {{ if NeedsRegPipe }}
            void RegPipe<TReq, TRes, TPipe>(string handlerName, PipelineConfig cfg, Func<TPipe, PipelineContext<TReq>, PipelineDelegate<TReq, TRes>, ValueTask<TRes>> invoker)
            {
                if (isSingleton)
                {
                    var pipeInstance = sp.GetRequiredService<TPipe>();
                    registry.RegisterPipeline<TReq, TRes>(handlerName, cfg, (ctx, next) => invoker(pipeInstance, ctx, next));
                }
                else
                {
                    registry.RegisterPipeline<TReq, TRes>(handlerName, cfg, (ctx, next) =>
                    {
                        var pipe = ctx.ServiceProvider.GetRequiredService<TPipe>();
                        return invoker(pipe, ctx, next);
                    });
                }
            }
            {{ end }}

            {{ if NeedsRegModule }}
            void RegModule<TReq, TRes>(string handlerName, string moduleName, string profileName)
            {
                registry.RegisterModule<TReq, TRes>(moduleName, handlerName, profileName);
            }
            {{ end }}

            {{ if NeedsRegNotification }}
            void RegNotification<TReq, THandler>(Func<THandler, NotificationContext<TReq>, ValueTask> call)
            {
                if (isSingleton)
                {
                    var inst = sp.GetRequiredService<THandler>();
                    registry.RegisterNotification<TReq>(ctx => call(inst, ctx));
                }
                else
                {
                    registry.RegisterNotification<TReq>(ctx =>
                    {
                        var h = ctx.ServiceProvider.GetRequiredService<THandler>();
                        return call(h, ctx);
                    });
                }
            }
            {{ end }}

            {{ for n in Notifications }}
            RegNotification<{{ n.RequestParameterTypeName }}, {{ n.ClassFullName }}>((inst, ctx) => inst.{{ n.MethodName }}(ctx));
            {{ end }}

            {{ for h in OrderedHandlers }}
            {{ if (h.PipelineCompileModels.size == 0 && h.ModuleCompileModels.size == 0) }}
            RegLight<{{ h.ClassFullName }}, {{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}",
                (inst, ctx) => {{ if h.IsVoidLike }} SpaceGeneratorRuntimeHelpers.ToNothing(inst.{{ h.MethodName }}(ctx)) {{ else }} {{ if h.IsValueTask }} inst.{{ h.MethodName }}(ctx) {{ else }} VT(inst.{{ h.MethodName }}(ctx)) {{ end }} {{ end }});
            {{ else }}
            Reg<{{ h.ClassFullName }}, {{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}",
                (inst, ctx) => {{ if h.IsVoidLike }} SpaceGeneratorRuntimeHelpers.ToNothing(inst.{{ h.MethodName }}(ctx)) {{ else }} {{ if h.IsValueTask }} inst.{{ h.MethodName }}(ctx) {{ else }} VT(inst.{{ h.MethodName }}(ctx)) {{ end }} {{ end }});
                {{ for p in h.PipelineCompileModels }}
                RegPipe<{{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}, {{ p.ClassFullName }}>("{{ h.HandlerName }}",
                    new PipelineConfig(){ Order = {{ p.Order }} },
                    (pipe, ctx, next) => {{ if p.IsValueTask }} pipe.{{ p.MethodName }}(ctx, next) {{ else }} VT(pipe.{{ p.MethodName }}(ctx, next)) {{ end }});
                {{ end }}
                {{ for m in h.ModuleCompileModels }}
                RegModule<{{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}", "{{ m.ModuleName }}", "{{ m.Profile }}");
                {{ end }}
            {{ end }}
            {{ end }}
        }
    }
}
