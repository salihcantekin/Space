# Space Project Documentation (Legacy Plain Text)

## Purpose
The purpose of this project is to build a high-performance alternative to MediatR while reducing or eliminating runtime reflection and excessive boilerplate. Space uses a Roslyn Source Generator to discover handlers, pipelines, notifications, and modules at compile time and emit static registration code. This avoids runtime scanning and improves startup and dispatch performance.

Key motivations:
- Remove runtime reflection cost (a common performance drawback).
- Reduce the need for multiple interface types per request/response pair.
- Allow multiple related handlers to reside in the same class via attributes.
- Provide an extensible module system (e.g., caching, auditing) as system pipelines.
- Support named handlers so multiple strategies can coexist for a single request/response pair.

## Required NuGet Packages
Minimal usage now requires referencing both:
- Space.Abstraction (brings the Space.SourceGenerator analyzer automatically)
- Space.DependencyInjection (DI extensions and runtime implementations)

Optional modules:
- Space.Modules.InMemoryCache (caching)
- Additional module packages in the future (audit, retry, etc.)

## Dependency Injection
```csharp
var services = new ServiceCollection();
services.AddSpace(opt =>
{
    opt.NotificationDispatchType = NotificationDispatchType.Parallel; // or Sequential
});
var provider = services.BuildServiceProvider();
ISpace space = provider.GetRequiredService<ISpace>();
```

## Handler Implementation
Handlers are methods annotated with `[Handle]`, accept `HandlerContext<TRequest>` and return `ValueTask<TResponse>` (or non-generic Task/ValueTask for `Nothing`).
```csharp
public sealed record UserLoginRequest(string UserName) : IRequest<UserLoginResponse>;
public sealed record UserLoginResponse(bool Success);

public class UserHandlers
{
    [Handle]
    public async ValueTask<UserLoginResponse> Login(HandlerContext<UserLoginRequest> ctx)
    {
        // var userService = ctx.ServiceProvider.GetRequiredService<UserService>();
        // bool exists = await userService.Login(ctx.Request);
        bool exists = true; // demo
        return new UserLoginResponse(exists);
    }
}

var response = await space.Send<UserLoginRequest, UserLoginResponse>(new UserLoginRequest("demo"));
```
Named handlers:
```csharp
public class PricingHandlers
{
    [Handle(Name = "Standard")] public ValueTask<PriceResult> Standard(HandlerContext<PriceQuery> ctx) => ValueTask.FromResult(new PriceResult("STD"));
    [Handle(Name = "Discounted", IsDefault = true)] public ValueTask<PriceResult> Discounted(HandlerContext<PriceQuery> ctx) => ValueTask.FromResult(new PriceResult("DISC"));
}
// Unnamed dispatch uses IsDefault handler
var discounted = await space.Send<PriceQuery, PriceResult>(new PriceQuery(5));
var standard = await space.Send<PriceQuery, PriceResult>(new PriceQuery(6), name: "Standard");
```

## Pipelines
Pipelines are middleware annotated with `[Pipeline]` and can be ordered via `Order`.
```csharp
public class UserPipelines
{
    [Pipeline(Order = 1)]
    public async ValueTask<UserLoginResponse> Audit(PipelineContext<UserLoginRequest> ctx, PipelineDelegate<UserLoginRequest, UserLoginResponse> next)
    {
        // before
        var res = await next(ctx);
        // after
        return res;
    }
}
```

## Notifications
Notification handlers react to published events.
```csharp
public sealed record UserLoggedInSuccessfully(string UserName);
public class LoginNotifications
{
    [Notification]
    public ValueTask LogFile(NotificationContext<UserLoggedInSuccessfully> ctx) => ValueTask.CompletedTask;
    [Notification]
    public ValueTask LogDb(NotificationContext<UserLoggedInSuccessfully> ctx) => ValueTask.CompletedTask;
}
await space.Publish(new UserLoggedInSuccessfully("demo"));
```

## Modules
Modules (e.g. Cache) are added by attributing handlers with module attributes such as `[CacheModule]`. They inject system pipelines before user-defined pipelines.
```csharp
public class UserQueries
{
    [Handle]
    [CacheModule(Duration = 60)]
    public ValueTask<UserProfile?> GetUser(HandlerContext<UserId> ctx) => ValueTask.FromResult<UserProfile?>(null);
}
```

## Custom Module Concept
A custom module involves:
1. An attribute implementing `ISpaceModuleAttribute`.
2. A `SpaceModule` subclass with `[SpaceModule(ModuleAttributeType = typeof(YourAttribute))]`.
3. A config type implementing `IModuleConfig`.
4. Optionally a provider type implementing a custom interface.
5. An extension method to register module + provider.

## Known Issues (Current)
- Early lazy resolution edge case for `ISpace` may produce null space reference in extremely first handler instantiation path (subsequent calls correct this).
- Module scoping for named handlers may apply module to all handlers of a request/response pair (refinement planned).

## Planned Improvements
- Attribute-level provider type specification (e.g. `[CacheModule(Provider = typeof(RedisCacheModuleProvider))]`).
- Global default module option configuration via DI options pattern.
- Enhanced module ordering constants and conflict diagnostics.

## Suggestions / Future Work
- Integrated structured logging via `ILoggerFactory`.
- Expanded retry / audit / metrics modules.

## Summary
Space focuses on build-time computation (source generation) to deliver a lean, low-overhead runtime mediation and messaging framework featuring:
- Attribute-first programming model
- Extensible pipelines & modules
- Named handler selection
- High-performance async dispatch
- No runtime reflection for discovery

For full, updated documentation prefer the Markdown files under `docs/` (e.g., `ProjectDoc.en.md`). This legacy plain text file is retained for compatibility.





